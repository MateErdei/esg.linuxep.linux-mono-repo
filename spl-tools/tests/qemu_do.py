#!/usr/bin/env python3
# Copyright 2023 Sophos Limited. All rights reserved.

import sys
import os
import subprocess

SPL_TOOLS_DIR = "spl-tools"
MONO_REPO_ON_VM = "/vagrant/esg.linuxep.linux-mono-repo"
SPL_TOOLS_ON_VM = os.path.join(MONO_REPO_ON_VM, SPL_TOOLS_DIR)
HOME_DIR = os.path.expandvars("$HOME")
SSH_KEY = os.path.join(HOME_DIR, ".ssh/spl-qemu")

TAP_RUN_PATCH = """
--- a/__main__.py
+++ b/__main__.py
This patch changes tap run to not attempt a build, using the inputs already there
@@ -195,7 +195,7 @@
         pubtap_exchange=pubtap_rabbit_exchange)
 
     if command == 'run':
-        fetch_enabled, build_enabled, test_enabled = False, True, True
+        fetch_enabled, build_enabled, test_enabled = False, False, True
     elif command == 'build':
         fetch_enabled, build_enabled, test_enabled = False, True, False
         build_backend = 'local'
--- a/_backend/local.py
+++ b/_backend/local.py
This patch enables support for output aggregation - this is only used for bullseye coverage currently
@@ -1,6 +1,7 @@
 import contextlib
 import os
 from typing import Any, Dict, Optional, AsyncGenerator
+from distutils.dir_util import copy_tree
 
 from dotdict import DotDict
 
@@ -57,8 +57,7 @@
     async def output_artifact(self, path: str, name: Optional[str], output: Optional[TaskOutput], raise_on_failure: bool,
                               reporter: AbstractStepReporter) -> Optional[OutputPath]:
         await reporter.output_uploaded(name, '(local)', str(path), status=Status.SUCCESS, kind='folder')
-        # NOTE: Task output aggregation is not supported for the local backend
-        return None
+        return path
 
     async def change_environment(self, environment: MachineEnvironment):
         raise NotImplementedError('Change environment is not supported on local machines')
@@ -109,8 +109,9 @@
                     inputs[input_name] = task_input
                     test_input = deps[inp]
                     if isinstance(test_input, AggregateInput):
-                        print('\\nWARNING: The local test backend does not support aggregate inputs: '
-                              f'TaskOutput({test_input.name}). The input will be skipped.')
+                        for task_name, machine_names in test_input.inputs.items():
+                            for machine_name, artifact_path in machine_names.items():
+                                copy_tree(artifact_path, os.path.join(str(task_input), task_name, machine_name))
                         continue
 
                     assert isinstance(test_input, AbstractInput)
"""


def add_quote(input_arg: str) -> str:
    if input_arg[0] == '"' or input_arg[0] == "'":
        return input_arg
    else:
        return '"' + input_arg + '"'


def find_monorepo_dir() -> str:
    find_result = subprocess.run(["git", "rev-parse", "--show-toplevel"], text=True, capture_output=True)
    return find_result.stdout.split("\n")[0]


# Create the temp file that will be executed inside the VM
def generate_tap_script(remote_dir: str, env_variables: str, quoted_args: [str]) -> str:
    temp_file_content = f"""#!/bin/bash
# This file is generated by spl-tools/tests/qemu_tap.py
set +ex

cd {MONO_REPO_ON_VM}

if [ ! -d /opt/tapvenv ]
then
  # TODO LINUXDAR-8050: move these two to ./tools/scripts/setup-devmachine.sh
  echo "> Creating TAP venv"
  sudo apt update
  sudo apt install -y python3-venv
  chmod +x ./tools/scripts/setup-devmachine.sh
  ./tools/scripts/setup-devmachine.sh
  sudo mkdir -p /opt/test
fi
sudo apt install -y gdb

# Clear the inputs
rm -rf /opt/test/inputs

# Patch tap
echo "> Patching TAP"
cd /opt/tapvenv/lib/python3.*/site-packages/tap
read -r -d '' PATCH << EOT
{TAP_RUN_PATCH}
EOT
if ! ( patch -p1 -R --force --dry-run &>/dev/null <<< "$PATCH" )
then
  patch -p1 -N <<< "$PATCH"
fi

cd {remote_dir}
. /opt/tapvenv/bin/activate
echo "> Running command: {env_variables} {' '.join(quoted_args)}"
{env_variables} {' '.join(quoted_args)}

# Unpatch tap
echo "> Reverting TAP patch"
cd /opt/tapvenv/lib/python3.*/site-packages/tap
if ! ( patch -p1 -N --force --dry-run &>/dev/null <<< "$PATCH" )
then
  patch -p1 -R <<< "$PATCH"
fi
"""
    return temp_file_content


def rsync(args):
    subprocess.check_call(["rsync", "-e", f"ssh -p 2222 -i {SSH_KEY}", "--rsync-path=sudo rsync", "-av"] + args)


def main():
    current_dir = os.path.abspath(os.getcwd())
    print(f"Current dir: {current_dir}")

    monorepo_root = find_monorepo_dir()
    print(f"Monorepo root dir: {monorepo_root}")

    sspl_tools_dir = os.path.join(monorepo_root, SPL_TOOLS_DIR)

    # Translate the arguments from the host machine to the VM
    remote_args = sys.argv[1:]
    copy_log_back = False
    # Add the --build-backend=local --test-backend=local flags for tap run if not specified
    if len(remote_args) >= 2 and remote_args[0] == "tap" and remote_args[1] == "run":
        copy_log_back = True

        def append_if_not_found(prefix, full):
            found = False
            for arg in remote_args[2:]:
                if arg.startswith(prefix):
                    found = True
                    break
            if not found:
                remote_args.append(full)

        append_if_not_found("--build-backend", "--build-backend=local")
        append_if_not_found("--test-backend", "--test-backend=local")

    # Add quotes to args
    quoted_args = [add_quote(a) for a in remote_args]

    remote_dir = current_dir.replace(monorepo_root, MONO_REPO_ON_VM)

    env_variables = ""
    for key in os.environ:
        if key.startswith("TAP_PARAMETER_"):
            env_variables += f" {key}={add_quote(os.environ[key])}"

    temp_file_content = generate_tap_script(remote_dir, env_variables, quoted_args)

    tmp_file_on_host = os.path.join(sspl_tools_dir, "tmpscript.sh")
    tmp_file_on_guest = os.path.join(SPL_TOOLS_ON_VM, "tmpscript.sh")

    with open(tmp_file_on_host, "w") as f:
        f.write(temp_file_content)
        print(f"Wrote test execution file {tmp_file_on_host}")

    # Need to create these directories as rsync commands fail otherwise
    if subprocess.call(["ssh", "-p", "2222", "-i", SSH_KEY, "ubuntu@localhost", "-t", f"sudo mkdir -p {MONO_REPO_ON_VM}/bazel-out/k8-dbg/bin/sdds"]) != 0:
        print("Failed to ssh: Is the VM running? If not, start it with ./spl-tools/tests/qemu.sh")
        return 1

    # We can almost do a straight rsync to get everything onto the VM
    # The bazel symlinks are just copied, the files within are not transferred
    # This poses a problem only for Warehouse builds, so we need to copy the sdds/bazel-bin "directory" deeply
    rsync(["--delete",
           "--exclude", "/bazel-out",  # To avoid removing it in the destination
           "--exclude", "/spl-tools/tests",  # To avoid copying VM images
           "--exclude", "/.clwb",
           f"{monorepo_root}/",
           f"ubuntu@localhost:{MONO_REPO_ON_VM}/"])
    if os.path.isdir(f"{monorepo_root}/bazel-out/k8-dbg/bin/sdds"):
        rsync(["--delete",
               "--copy-links",  # To copy bazel-out/k8-dbg/bin/sdds/ as a directory rather than symlink
               f"{monorepo_root}/bazel-out/k8-dbg/bin/sdds/",
               f"ubuntu@localhost:{MONO_REPO_ON_VM}/bazel-out/k8-dbg/bin/sdds/"])

    # Run the command in the VM
    subprocess.call(["ssh", "-p", "2222", "-i", SSH_KEY, "ubuntu@localhost", "-t", f"sudo bash {tmp_file_on_guest}"])

    if copy_log_back:
        # Copy log back to dev machine, so it can be viewed
        rsync(["ubuntu@localhost:/opt/test/logs/log.html", current_dir])
        print("View log file by running:")
        # From WSL open in default Windows browser
        print("Explorer.exe log.html")

    return 0


if __name__ == "__main__":
    sys.exit(main())
